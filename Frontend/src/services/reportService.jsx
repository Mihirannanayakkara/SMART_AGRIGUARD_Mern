import axios from 'axios';
import { saveAs } from 'file-saver';
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';

const API_BASE_URL = 'http://localhost:5557/api';

// Define role colors for consistent styling across reports
const roleColors = {
  'farmer': { color: '#4CAF50', bgColor: '#E8F5E9' },
  'OrganicFarmer': { color: '#2196F3', bgColor: '#E3F2FD' },
  'cropFarmer': { color: '#FFC107', bgColor: '#FFF8E1' },
  'greenhouseFarmer': { color: '#9C27B0', bgColor: '#F3E5F5' },
  'forester': { color: '#3F51B5', bgColor: '#E8EAF6' },
  'gardener': { color: '#E91E63', bgColor: '#FCE4EC' },
  'soilTester': { color: '#607D8B', bgColor: '#ECEFF1' },
  'agriculturalResearcher': { color: '#FF5722', bgColor: '#FBE9E7' }
};

export const ReportService = {
  /**
   * Generate and download a report based on user data
   * @param {Array} users - The array of user objects
   * @param {String} format - The format of the report (pdf, csv, xlsx, json)
   * @param {Object} options - Additional options for the report
   */
  generateUserReport: async (users, format = 'pdf', options = {}) => {
    try {
      // Apply filters if provided in options
      let filteredUsers = [...users];
      
      if (options.searchTerm) {
        const term = options.searchTerm.toLowerCase();
        filteredUsers = filteredUsers.filter(user => 
          user.username?.toLowerCase().includes(term) ||
          user.email?.toLowerCase().includes(term) ||
          user.role?.toLowerCase().includes(term)
        );
      }
      
      if (options.roleFilter && options.roleFilter !== '') {
        filteredUsers = filteredUsers.filter(user => user.role === options.roleFilter);
      }
      
      // Prepare data for reports - clean and transform as needed
      const reportData = filteredUsers.map(user => ({
        username: user.username || 'N/A',
        email: user.email || 'N/A',
        role: user.role || 'N/A',
        createdAt: user.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'N/A',
      }));

      // Get metadata for enhanced reports
      const metadata = ReportService.getReportMetadata(filteredUsers);
      
      // Add metadata to options
      const enhancedOptions = {
        ...options,
        metadata,
        summary: options.summary || `This report contains ${filteredUsers.length} users.`,
        additionalFooter: `Report generated by Farm Management System on ${new Date().toLocaleString()}`
      };
      
      // Generate the report in the requested format
      switch (format.toLowerCase()) {
        case 'pdf':
          return ReportService._generatePdfReport(reportData, enhancedOptions);
        case 'csv':
          return ReportService._generateCsvReport(reportData, enhancedOptions);
        case 'xlsx':
          return ReportService._generateExcelReport(reportData, enhancedOptions);
        case 'json':
          return ReportService._generateJsonReport(reportData, enhancedOptions);
        default:
          throw new Error(`Unsupported report format: ${format}`);
      }
    } catch (error) {
      console.error('Error generating report:', error);
      throw error;
    }
  },
  
  /**
   * Generate a PDF report
   * @private
   */
    _generatePdfReport: (data, options = {}) => {
    try {
      // Create a new jsPDF instance with proper configuration
      const doc = new jsPDF('portrait', 'mm', 'a4');
      
      // Add company name and title
      const companyName = "Agriguard";
      const title = options.title || 'User Management Report';
      const subtitle = options.subtitle || `Generated on: ${new Date().toLocaleString()}`;
      
      // Add report header with improved styling
      doc.setFillColor(39, 174, 96); // Green header background
      doc.rect(0, 0, doc.internal.pageSize.getWidth(), 20, 'F');
      
      // Company name at the top
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(12);
      doc.setTextColor(255, 255, 255); // White text
      doc.text(companyName, 14, 8);
      
      // Title with better positioning and styling
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(20);
      doc.setTextColor(255, 255, 255); // White text
      doc.text(title, doc.internal.pageSize.getWidth() / 2, 13, { align: 'center' });
      
      // Subtitle
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(12);
      doc.setTextColor(80, 80, 80); // Dark gray text
      doc.text(subtitle, doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });
      
      // Add report summary if provided
      if (options.summary) {
        doc.setFont('helvetica', 'italic');
        doc.setFontSize(10);
        doc.setTextColor(100, 100, 100); // Gray text
        doc.text(options.summary, 14, 40);
        doc.line(14, 45, doc.internal.pageSize.getWidth() - 14, 45); // Horizontal line
      }
      
      // Create the table with improved styling
      const tableColumn = ["Username", "Email", "Role", "Created Date"];
      const tableRows = data.map(user => [
        user.username,
        user.email,
        user.role,
        user.createdAt
      ]);

      // Use autoTable directly
      autoTable(doc, {
        startY: options.summary ? 50 : 40,
        head: [tableColumn],
        body: tableRows,
        headStyles: {
          fillColor: [39, 174, 96], // Green header
          textColor: [255, 255, 255],
          fontStyle: 'bold',
          halign: 'center'
        },
        alternateRowStyles: {
          fillColor: [240, 245, 240] // Light green tint
        },
        columnStyles: {
          0: { cellWidth: 40 }, // Username
          1: { cellWidth: 60 }, // Email
          2: { cellWidth: 40 }, // Role
          3: { cellWidth: 40 }  // Created Date
        },
        styles: {
          font: 'helvetica',
          fontSize: 10,
          cellPadding: 5,
          overflow: 'linebreak',
          valign: 'middle'
        },
        margin: { top: 15, left: 14, right: 14 },
        didDrawPage: function(data) {
          // Add page number and company name on each page
          doc.setFontSize(8);
          doc.setTextColor(150, 150, 150);
          doc.text(
            `${companyName} - Page ${doc.internal.getCurrentPageInfo().pageNumber} of ${doc.internal.getNumberOfPages()}`,
            doc.internal.pageSize.getWidth() - 20,
            doc.internal.pageSize.getHeight() - 10
          );
        }
      });
      
      // Get the final Y position after the table is drawn
      const finalY = doc.lastAutoTable ? doc.lastAutoTable.finalY : doc.internal.pageSize.getHeight() - 20;
      
      // Add summary footer
      doc.setFontSize(10);
      doc.setTextColor(80, 80, 80);
      doc.text(`Total Users: ${data.length}`, 14, finalY + 10);
      
      if (options.additionalFooter) {
        doc.text(options.additionalFooter, 14, finalY + 16);
      }
      
      // Add company footer
      doc.setFontSize(8);
      doc.setTextColor(100, 100, 100);
      doc.text(`Â© ${new Date().getFullYear()} ${companyName} - All Rights Reserved`, 
        doc.internal.pageSize.getWidth() / 2, 
        doc.internal.pageSize.getHeight() - 5, 
        { align: 'center' });
      
      // Save the PDF using file-saver for better browser compatibility
      const fileName = options.fileName || `${companyName.toLowerCase()}-user-report-${new Date().toISOString().split('T')[0]}.pdf`;
      const pdfBlob = doc.output('blob');
      saveAs(pdfBlob, fileName);
      
      return { success: true, fileName };
    } catch (error) {
      console.error('Error generating PDF report:', error);
      throw error;
    }
  },
  
  /**
   * Generate a CSV report
   * @private
   */
    _generateCsvReport: (data, options = {}) => {
    try {
      const companyName = "Agriguard";
      // Create CSV content
      const headers = Object.keys(data[0]);
      const csvRows = [];
      
      // Add headers
      csvRows.push(headers.join(','));
      
      // Add data rows
      for (const row of data) {
        const values = headers.map(header => {
          const value = row[header];
          // Escape values containing commas or quotes
          if (value && (value.includes(',') || value.includes('"'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value;
        });
        csvRows.push(values.join(','));
      }
      
      // Create and download file
      const csvString = csvRows.join('\n');
      const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
      const fileName = options.fileName || `${companyName.toLowerCase()}-user-report-${new Date().toISOString().split('T')[0]}.csv`;
      saveAs(blob, fileName);
      
      return { success: true, fileName };
    } catch (error) {
      console.error('Error generating CSV report:', error);
      throw error;
    }
  },
  /**
   * Generate an Excel report
   * @private
   */
    _generateExcelReport: (data, options = {}) => {
    try {
      const companyName = "Agriguard";
      // Create workbook and worksheet
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.json_to_sheet(data);
      
      // Add some styling
      const colWidths = [
        { wch: 15 }, // username
        { wch: 25 }, // email
        { wch: 15 }, // role
        { wch: 15 }, // createdAt
      ];
      
      ws['!cols'] = colWidths;
      
      // Add the worksheet to the workbook
      XLSX.utils.book_append_sheet(wb, ws, options.sheetName || `${companyName} Users`);
      
      // Generate Excel file
      const fileName = options.fileName || `${companyName.toLowerCase()}-user-report-${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(wb, fileName);
      
      return { success: true, fileName };
    } catch (error) {
      console.error('Error generating Excel report:', error);
      throw error;
    }
  },
  
  /**
   * Generate a JSON report
   * @private
   */
    _generateJsonReport: (data, options = {}) => {
    try {
      const companyName = "Agriguard";
      // Format JSON with indentation for readability
      const jsonContent = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonContent], { type: 'application/json' });
      const fileName = options.fileName || `${companyName.toLowerCase()}-user-report-${new Date().toISOString().split('T')[0]}.json`;
      saveAs(blob, fileName);
      
      return { success: true, fileName };
    } catch (error) {
      console.error('Error generating JSON report:', error);
      throw error;
    }
  },
  
  /**
   * Generate a report using the server API (alternative approach)
   * @param {Object} options - Report options including format, filters, etc.
   */
  generateReportFromServer: async (options = {}) => {
    try {
      const response = await axios.post(`${API_BASE_URL}/reports/users`, options, {
        responseType: 'blob' // Important for handling binary responses
      });
      
      // Create a file name based on format
      const format = options.format || 'pdf';
      const fileName = options.fileName || `user-report-${new Date().toISOString().split('T')[0]}.${format}`;
      
      // Create a download link
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', fileName);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      return { success: true, fileName };
    } catch (error) {
      console.error('Error generating report from server:', error);
      throw error;
    }
  },
  
  /**
   * Get report metadata and statistics
   * @param {Array} users - The array of user objects
   * @returns {Object} Report metadata and statistics
   */
  getReportMetadata: (users) => {
    const roleCounts = {};
    let oldestUser = null;
    let newestUser = null;
    
    users.forEach(user => {
      // Count roles
      roleCounts[user.role] = (roleCounts[user.role] || 0) + 1;
      
      // Find oldest and newest users
      if (user.createdAt) {
        const createdDate = new Date(user.createdAt);
        if (!oldestUser || createdDate < new Date(oldestUser.createdAt)) {
          oldestUser = user;
        }
        if (!newestUser || createdDate > new Date(newestUser.createdAt)) {
          newestUser = user;
        }
      }
    });
    
    return {
      totalUsers: users.length,
      roleCounts,
      oldestUser: oldestUser ? {
        username: oldestUser.username,
        createdAt: new Date(oldestUser.createdAt).toLocaleDateString()
      } : null,
      newestUser: newestUser ? {
        username: newestUser.username,
        createdAt: new Date(newestUser.createdAt).toLocaleDateString()
      } : null,
      generatedAt: new Date().toLocaleString()
    };
  }
};

export default ReportService;